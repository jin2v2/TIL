## OOP
## 상속
- 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려 받는 것
- 코드 재사용 + 계층 구조 + 유지 보수의 용이성
``` python
class Animal:
  def eat(self):
    print('먹는 중')

class Dog(Animal): 
  # 상속하려는 부모 클래스 이름 선언
  def bark(self):
    print('멍멍')

my_dog = Dog()
my_dog.bark() # 멍멍

my_dog.eat() # 먹는 중
```
## 상속 없이 구현하는 경우
- 각각의 고유 속성을 표현하기 어려움.
- 클래스를 각각 분리 했지만 메서드가 중복으로 정의될 수 있음

## 메서드 오버라이딩
- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하느 것
- 자식 클래스에서 메서들르 다시 정의하면, 부모 메서드 대신 자식 클래스의 메서드가 실행됩니다.
- 오버라이딩 : <span style="color:red"> 동일한 이름과 매개변수를 사용하지만, 내부 동작을 원하는 대로 바꿀 수 있게 해준다.
- ==> 부모 클래스의 기능을 유지하면서, 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용
``` python
class Animal:
  def eat(self):
    print('Animal이 먹는 중')

class Dog(Animal):
  # 부모 클래스의 eat 메서드를 재정의(오버라이딩)
  def eat(self):
    print('Dog가 먹는 중')

my_dog = Dog()
my_dog.eat() # Dog가 먹는 중
```

## 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있습니다.
- 상속받은 모든 클래스의 요소를 활용 가능합니다.
- 중복된 속성이나 메서드가 있는 경우 <span style="color:red"> 상속 순서에 의해 결정된다.
``` python
class Person:
  def __init__(self, name):
    self.name = name

  def greeting(self):
    return f'안녕, {self.name}'

class Mom(Person):
  gene = 'XX'

  def swim(self):
    return '엄마가 수영'

class Dad(Person):
  gene = 'XY'

  def walk(self):
    return '아빠가 걷기'
  
class FirstChild(Dad, Mom): # Dad, Mom을 상속받음.
  def swim(self):
    return '첫째가 수영'
  
  def cry(self):
    return '첫째가 응애'

baby1 = FirstChild('아가')
print(baby1.cry())
print(baby1.swim())
print(baby1.walk())
print(baby1.gene()) # Dad를 먼저 상속 받기에 XY가 된다.
```

### 다이어몬드 문제
- 해결책 : 
- MRO 알고리즘 사용
- C3L 선형화 알고리즘을 적용 :
    - 자식은 부모보다 먼저, 겹치는 부모는 가장 나중에. ClassName.mro()
- 1. 자식 클래스 우선
- 2. 왼쪽 부모 우선
- 3. 중복 방문 방지

## MRO
- 파이썬이 메서드를 찾는 순서에 대한 규칙
- 메서드 결정 순서
- <span style="color:red"> 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할지 순서를 정의.

## super() 메서드
- MRO에 따라 현재 클래스의 부모 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장함수
- 부모 클래스의 생성자(또는 메서드)를 호출하기 위해 사용
- 명시적으로 부모 클래스 이름을 적지 않아도 MRO에 따라 자동으로 올바른 메서드를 찾아 실행할 수 있다.
- 1. 단일 상속 구조
- 2. 다중 상속 구조
``` python
# 1. 단일 상속
class Person:
  def __init__(self, name, age, number, email):
    self.name = name
    self.age = age
    self.number = number
    self.email = email

class Student(Person): # Person 상속
  def __init__(self, name, age, number, email, student_id):
    super().__init__(name, age, number, email)
    self.student_id = student_id
```
- 생성자에서 super()__init__()를 호출
- 단일 상속에서는 super()를 사용해 부모 클래스를 직접 명시하지 않고 메서드 호출

```python
# 2. 다중 상속
class ParentA:
  def __init__(self):
    self.value_a = 'ParentA'
  
  def show_value(self):
    print(f'Value from ParentA: {self.value_a}')

class ParentB:
  def __init__(self):
    self.value_b = 'ParentB'
  
  def show_value(self):
    print(f'Value from ParentB : {self.value_b}')
  
class Child(ParentA, ParentB):
  def __init__(self):
    super().__init__()
    self.value_c = 'Child' # 이게 없고 부모한테 있다고 하면 부모꺼 출력되는거.
                          # 부모한테도 있고, 나한테도 있으면, 오버라이딩 발생해서 내꺼 출력.
  
  def show_value(self):
    super().show_value() # 부모꺼 출력
    print(f'Value from Child : {self.value_c}') # 내꺼 출력

child = Child()
child.show_value()

print(child.value_c) # 부모 갔다가 없어서 내꺼 출력
# 만약에, 부모에 value_c가 있어도, 나한테 value_c가 있으면 재할당되어서(오버라이딩) 내꺼 출력.

print(child.value_a) # 부모 갔는데 있어서 부모꺼 출력
```
## mro(), __mro__ 사용 예시
``` python
class A:
  def __init__(self):
    print('A Constructor')

class B(A):
  def __init__(self):
    super().__init__()
    print('B Constructor')

class C(A):
  def __init__(self):
    super().__init__()
    print('C Constructor')

class D(B,C):
  def __init__(self):
    super().__init__()
    print('D Constructor')

# D -> B -> C -> A
print(D.mro())
print(D.__mro__)
```

## 에러와 예외
### 버그
- 소프트웨어에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치

### 디버깅
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업

### 에러
- 프로그램 실행 중에 발생하는 예외 상황
- 문법 에러(Syntax Error) : 오타, 문법적 오류
- 예외(Exception) : 실행 중 감지되는 에러
- 내장예외 : 예외 상황을 나타내는 예외 클래스들
    1. ZeroDivisionError(나누기, 모듈연산의 두 번쨰 인자가 0일때 발생)
    2. NameError(지역,전역 이름을 찾을 수 없을 때)
    3. TypeError(타입 불일치)
    4. TypeError(인자누락)
    5. TypeError(인자초과)
    6. TypeError(인자타입 불일치)
    7. ValueError
    8. IndexError
    9. KeyError
    10. ModuleNotFoundError
    11. ImportError
    12. KeyboardInterrupt
    13. IndentationError

### 예외처리
- 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법
1. try : 예외가 발생할 수 있는 코드 작성
2. except : 예외가 발생했을 때 실행할 코드 작성
3. else : 예외가 발생하지 않았을 때 실행할 코드 작성
4. finally : 예외 발생 여부와 상관없이 항상 실행할 코드 작성
``` python
try: # 예외가 발생할 수 있는 코드를 작성
  x = int(input('숫자를 입력하세요: '))
  y = 10 / x
except ZeroDivisionError: 
# 예외가 발생했을 때 처리할 코드 작성
# 숫자 0을 입력했을 때 발생
  print('0으로 나눌 수 없습니다.')
except ValueError: # 문자를 입력했을 때
  print('유효한 숫자가 아닙니다.')
except Exception: # 항상 범용적인 예외처리는 마지막에 두어야 한다. ==> Why?? : 해당 except 절이 앞에 사용되면 이후 except문은 실행되지 못하기 때문.
  print('숫자를 넣어주세여')

# 가장 구체적인 예외부터 처리하고, 마지막에 범용 예외를 처리.

else: # 예외가 발생하지 않았을 때 추가 작업을 진행
  print(f'결과: {y}')
finally: # 무~~~~조건 실행
  print('프로그램이 종료되었습니다.')
```
### 예외 객체 다루기
### as 키워드
- 예외객체 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
``` python
my_list = []
try:
  number = my_list[1]
except IndexError as error:
  print(f'{error}가 발생했습니다.')
```
### try-except와 if-else
- 입력값이 정수가 아니면 ValueError 예외가 발생해 오류 메시지를 출력합니다.
```python
try:
  x = int(input('숫자를 입력하세요: '))
  if x < 0:
    print('음수는 허용되지 않습니다.')
  else:
    print('입력한 숫자:', x)
except ValueError:
  print('오류 발생')
```
- EAFP : 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)
    - 일단 실행하고 예외를 처리
    - 예외 상황을 예측하기 어려운 경우

- LBYL : 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)
    - 실행하기 전에 조건을 검사
    - 예외 상황을 미리 방지하고 싶을 때
