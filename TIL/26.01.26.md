# <span style="color:red">

## Data Structure
- 데이터 구조(자료구조)
- 여러 데이터를 효과적으로 사용 관리하기 위한 구조(str, list, dict)

## 메서드(method) : 객체에 속한 함수
- 객체가 특정 작업을 수행하도록 정의된 함수

## 클래스 내부에 정의되는 함수
- 메서드는 어딘가(클래스)에 속해있는 함수이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재
- ex: 데이터 타입 객체.메서드() 'hello'.capitalize()

- 객체 : 특정 데이터(정보)와 그 데이터를 처리하는 기능(메서드)를 하나로 묶은 것

## 공통 시퀀스 메서드
|메서드|설명|
|---------------|----------------|
|s.index(x)|시퀀스에서 첫 번째로 일치하는 항목 x의 인덱스를 반환.|
|s.count(x)|시퀀스 s에서 등장하는 항목 x의 개수를 반환|


## 불변 시퀀스 메서드
- 문자열 전용
- 문자열 탐색 및 검증 메서드

  |메서드|설명|
  |---------------|----------------|
  |s.find(x)|x의 첫 번째 위치를 반환. 없으면 -1을 반환|
  |s.isupper()|문자열 내의 모든 케이스 문자가 대문자인지 확인|
  |s.islower()|문자열 내의 모든 케이스 문자가 소문자인지 확인|
  |s.isalpha()|문자열의 모든 문자가 알파벳이고 하나 이상의 문자가 포함되어 있으면 True를 반환|

## 문자열 조작

  |메서드|설명|사용|
  |---------------|----------------|----------------|
  |s.replace(old,new,[,count])|기존문자열에서 old를 count만큼 new로 모두 바뀐 문자열을 반환|--|
  |str.strip([chars])|선행과 후행 문자가 제거된 문자열의 복사본을 돌려줌|양 끝의 공백제거(가운데 x)|
  |str.split(sep=None, maxsplit=-1)|sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 <span style="color:red">리스트를 반환|공백을 기준으로 분리|
  |str.join(iterable)|구분자로 iterable의 문자열을 연결한 문자열을 반환|sentence1 = ' '.join(words)|
  |str.capitalize()|가장 첫 번째 글자를 대문자로 변경|--|
  |str.title()|문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환|--|
  |str.upper()|모두 대문자로 변경|--|
  |str.lower()|모두 소문자로 변경|--|
  |str.swapcase()|대 <-> 소문자 서로 변경|--|

## 가변 시퀀스 메서드
- 리스트 전용
- 값 추가 및 삭제

|메서드|설명|사용|
|---------------|----------------|----------------|
|<span style="color:red">L.append(x)|리스트 마지막에 항목 x를 추가|--|
|<span style="color:red">L.extend(iterable)|iterable의 모든 항목들을 리스트 끝에 추가(+=과 같은 기능)|--|
|L.insert(i, x)|리스트 인덱스 i에 항목 x를 삽입|--|
|L.remove(x)|리스트에서 첫 번째로 일치하는 x를 제거 항목이 존재하지 않을 경우, ValueError|--|
|<span style="color:red">L.pop()|리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거|--|
|<span style="color:red">L.pop(i)|리스트의 인덱스 i에 있는 항목을 반환 후 제거|--|
|L.clear()|리스트의 모든 항목 제거|--|

## 정렬
|메서드|설명|사용|
|---------------|----------------|----------------|
|L.reverse()|리스트의 순서를 역순으로 변경(정렬 X)|--|
|L.sort()|리스트를 정렬(매개변수 이용가능)|--|
|L.sort(reverse=True)|리스트를 내림차순 정렬|--|

## 복사
- 객체와 참조
- 기변/불변 객체의 개념

- Mutable(가변)객체
    - 생성 후 내용을 변경할 수 있는 객체(리스트, 딕셔너리, 집합)
- Immutable(불변)객체
    - 생성 후 내용을 변경할 수 없는 객체(정수, 실수, 문자열, 튜플)

## 변수 할당의 의미
- 객체에 대한 참조를 생성하는 과정
- 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함.
- 변수는 객체의 메모리 주소를 저장. 여러 변수가 동일한 객체를 참조할 수 있음.
- id() 함수를 사용한 메모리 주소 확인
- id() + is연산자

## 가변/불변 메모리 관리 방식의 이유
- 성능 최적화
    - 불변 객체 : 변경이 불가능하므로, 여러 변수가 동일한 객체를 안전하게 공유할 수 있음.
    - 가변 객체 : 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 기존 객체를 직접 수정할 수 있음. 이로 인해 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상시킴

- 메모리 효율성
    - 불변 객체 : 동일한 값을 가진 여러 변수가 같은 객체를 참조할 수 있어 메모리 사용을 최소화 할 수 있음
    - 가변 객체 : 크기가 큰 데이터를 효율적으로 수정할 수 있음

## 얕은 복사
- 객체의 최상위 요소만 새로운 메모리에 복사하는 방법
- 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사됨

- 얕은 복사의 함정 : '가변 객체'
- 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 가변 객체를 수정하면, 원본 객체와 복사본 객체가 함께 변경됩니다.
- 이는 복사본의 중첩 객체가 여전히 원본 객체의 중첩 객체를 참조하고 있기 때문입니다.

## 얕은 복사 구현 방법
- 동일한 객체들을 참조한다.

1. 리스트 슬라이싱

2. copy() 메서드

3. list() 함수

## 얕은 복사의 한계
- 2차원 리스트 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우 : 최상위 리스트만 복사되고, 내부 객체의 주소는 같기 때문에 함께 변경된다.

## 깊은 복사
- 객체의 모든 수준의 요소를 새로운 메모리에 복사하는 방법
- 중첩된 객체까지 모두 새로운 객체로 생성됨

- 깊은 복사는 원본 객체와 복사본이 완전히 독립적임을 보장한다.
- 복사본의 어떤 수준에 있는 중첩된 내용을 변경하더라고 원본 객체에는 절대 영향을 주지 않습니다.
- copy 모듈의 deepcopy()함수

```python
import copy

new_object = copy.deepcopy(original_object)

```

## List Comprehension
- 간결하고 효율적인 리스트 생성 방법

``` python
[expression for 변수 in iterable]
list(expression for 변수 in iterable)

[표현식 for 변수 in 순회 가능한 객체 if 조건]

# ex:
# 사용 전
numbers = [1,2,3,4,5]
squared_numbers = []
for num in numbers:
  squared_numbers.append(num**2)
  print(squared_numbers)

# 사용 후
numbers = [1,2,3,4,5]

squared_numbers = [num**2 for num in numbers]

print(squared_numbers)

>>> [1,4,9,16,25]

```

```python
# 2차원 배열 생성시
data1 = [[0] * 5 fir _ in range(5)]
data2 = [[0 for _ in range(5)] for _ in range(5)]
>>> 
[[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0]]
```
## 리스트를 생성하는 3가지 방법
```python
# 1. loop
result = []
for i in range(10):
  result1.append(i)

# 2. list comprehension
result2 = [i for i in range(10)]
# result2 = list(i for i in range(10))

# 3. map
result3 = list(map(lambda i:i, range(10)))

```

## 메서드 체이닝(Method Chaining)
- 여러 메서드를 연속해서 호출하는 방식
``` python
# 1. 단계별로 실행하기
text = 'heLLo, woRld!'
step1 = text.swapcase()
print('1단계 결과:', step1)

step2 = step1.replace('l','z')

# 2. 한 줄로 실행하기
new_text = text.swapcase().replace('l','z')
print('최종 결과:', new_text)

```

```python
# 리스트 메서드 체이닝의 흔한 실수
# 1. sort()는 None을 반환하므로, 변수에 아무것도 저장되지 않음
# 해결 : 
# 해결 1. 내장 함수 sorted()사용
sorted_numbers = sorted(numbers)
print(sorted_numbers)

# 해결 2. 메서드를 단계별로 나누어 작성
copied_list = numbers.copy()
copied_list.sort()
print(copied_list)

# 2. append()가 반환한 None 뒤에 메서드를 이을 수 없음
# None을 반환하는 메서드는 메서드 체이닝 불가능
```

## 문자 유형 판별 메서드
|메서드|설명|사용|
|---------------|----------------|----------------|
|isdecimal()|문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True|--|
|isdigit()|isdecimal()과 비슷하지만, 유니코드 숫자도 인식|--|
|isnumeric()|isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식(분수, 지수, 루트 기호도 숫자로 인식)|--|