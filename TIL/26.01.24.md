# 



# 표현식 과 값
## 표현식(expression) 
- 하나의 값으로 평가 될 수 있는 모든 코드
  - ex) 3 + 5
  - ex) x > 10

## 평가 
- 표현식을 계산하여 그 결과인 값을 만들어내는 과정


## 값(value) 
- 표현식이 평가된 결과
  - ex) 숫자 값, 문자 값, 불리언 값


### - 표현식에서 평가를 거쳐야 값이 된다.
### - 표현식 그 자체가 값은 아님.

## 문장(statement)
- 특정 동작을 지시하는, 실행가능한 코드의 최소 단위
- 할당문, 조건문, 반복문, 제어문 등

## 표현식 VS 문장
- 코드를 실행했을 때 값이 남는가?
- 네(표현식), 아니오(문장)


# 변수
 - 값을 나중에 다시 사용하기 위해 그 값에 붙여주는 고유한 이름
 - 메모리 주소가 존재.(참조)(주소 값을 가지는 것이 아님)
 - 값+타입+주소 정보를 묶은 것을 객체(object)라고 부름
 - 객체를 가리키는 이름
    
    - 재할당 : 이미 값이 할당된 변수에 새로운 값을 다시 할당 하는 것


## 1. 변수 할당
- 표현식이 만들어 낸 값에 이름을 붙이는 과정
- degrees = 36.5
  - degrees -> 변수 이름
  - = -> 할당 연산자
  - 36.5 -> 표현식

## 2. 변수명 규칙
  1. 영문 알파벳, 언더스코어, 숫자로 구성
  2. 숫자로 시작 X
  3. 대소문자를 구분
  4. 파이썬 내부 예약어는 이름으로 사용 불가

## 타입
- 변수나 값이 가질 수 있는 데이터의 종류

- 타입의 구성요소 2가지

  1. 값(피연산자)
  2. 연산자

## 데이터 타입 분류
  1. Numeric Types : int, float, complex
  2. Text Sequence Type : str
  3. Sequence Types : list, tuple, range
  4. Non-Sequence Types : dict, set
  5. 기타 : boolean, None, Functions

### 연산자 우선순위
  0. 괄호 ()
  1. 지수 **
  2. 음수부호 -, +
  3. 사칙연산 *, /, //, %
  4. 사칙연산 +, -
  5. 비교연산 <, >, >=, <=, !=, ==
  6. 할당연산 =, %=, *=, /=, //=, +=, -=
  7. 식별연산 is, is not
  8. 멤버십연산 in, not in
  9. 논리연산 not, and, or

### Sequence Types(str, list, tuple, range)
  - 여러 개의 값들을 순서대로 나열하여 저장하는 자료형
  - 고유한 번호(인덱스)가 존재
  
  - 시퀀스 타입 5가지 특징
    1. 순서(order)
    2. 인덱싱(indexing)
    3. 슬라이싱(slicing)
    4. 길이(length)
    5. 반복(iteration)

### str
- 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
- 이스케이프 시퀀스
    1. \n : 줄 바꿈
    2. \t : 탭
    3. \\ : 백 슬래시
    4. \' : 작은 따옴표
    5. \" : 큰 따옴표

- fstring
  - 문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법
  - ex: print(f'이름은 {name}이고, 나이는{age}입니다.)

- str : 변경 불가능한 시퀀스
  - 바꾸는 방법 : 값을 조합하여 새로운 문자열을 만들어야 함.

| 컬렉션 명 | 변경 가능(mutable) | 순서 존재(sequence) | 중복 가능 |
| --- | --- | --- | --- |
| list | O | O | O |
| str | X | O |  |
| tuple | X | O |  |
| dict | O | X(순서보장x) | X |
| set | O | X(순서보장x) | X |
| range | X |  |  |
| 숫자 | X |  |  |
| 변수 | O |  |  |

## 리스트 list
- 시퀀스(인덱싱, 슬라이싱, 길이확인, 반복) + 변경가능(유연성과 효율성 보장)
- []안에 ,로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경 가능
- 중첩 리스트[바깥 리스트][안쪽 리스트]

## 튜플 tuple
- 시퀀스(인덱싱, 슬라이싱, 길이확인, 반복) + 변경 불가능(안정성과 무결성 보장)
- ()안에 ,로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 소괄호 없이도 만듦
- 단일 요소 튜플을 만들 때는 후행 쉼표 사용
    - ex) ex_tuple = (1,)

## range
- 연속된 정수를 생성하는 변경 불가능한 자료형
- step이 음수일 때(start값이 stop보다 커야함)
    - ex: range(15,6,-1)

## 딕셔너리 dict
- key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
- {}안에 ,로 구분하여 만듦
- Key(중복불가), Value(중복가능)
- Key를 통한 접근 -> [] 사용
- Key는 변경 불가능한 자료형만 사용 가능

## 셋 set
- 순서와 중복이 없는 변경 가능한 자료형
- {}안에 ,로 구분하여 만듦
- 집합(|, &, -)

## Other Types
- None : 값이 없음을 표현하는 데이터 타입
- Boolean : True / False
- Collection : 여러 개의 값을 하나로 묶어 관리하는 자료형

## 형변환(Type Conversion)
- 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
1. 암시적 형변환 : 파이썬이 자동으로 처리
    1. 정수와 실수 덧셈
    2. 불리언과 정수 덧셈
    3. 불리언간 덧셈

2. 명시적 형변환 : 개발자가 직접 함수로 지정
    - int, float, str, list, tuple, set

## == 연산자 VS is 연산자
- == 연산자 : 값이 같은지를 비교(동등성)

- is 연산자 : 객체 자체가 같은지를 비교(식별성)
    - 메모리 주소가 같은지를 비교
    - 싱글턴 객체(None, True, False)를 비교할 때 사용
      - 싱글턴 객체 : 프로그램 전체에서 오직 1개만 존재하도록 만들어진 특별한 객체

## 단축평가
- 논리 연산에서 전체 결과가 확정되면 나머지 부분은 평가하지 않는 동작
- ex: print(0 or 5) >>>> 5
    - 0은 False로 간주되므로 5가 출력된다.

# 함수
- 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
- 재사용성 + 가독성과 유지보수성 향상
  
  ``` python
  def get_sum(x, y): # x와 y는 매개변수
    """ 이것은 두 수를 받아 두 수의 합을 반환하는 함수입니다."""

    return x + y

  result_1 = get_sum(5,3) # 5와 3은 인자
  print(result_1)
  ```

  - 괄호안에 매개변수를 정의 : 함수에 전달 되는 값
  - Docstring : 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
  - return 키워드 이후 반환할 값을 명시
  - return 문이 없다면 None이 반환된다.

  ### print() 함수는 반환 값이 없음.
    - 값을 출력만 할 뿐

  - 매개변수(parameter) : 함수를 정의할 때, 함수가 받을 값을 나타내는 변수
  - 인자(argument) : 함수를 호출할 때, 실제로 전달되는 값

### 다양한 인자 종류
1. 위치 인자(Positional)
    - 함수 호출 시 인자의 위치에 따라 전달되는 인자
    - 함수 호출 시 반드시 값을 전달해야 함.

2. 기본 인자 값(Default)
    - 함수 정의에서 매개변수에 기본 값을 할당하는 것
    - 인자를 전달하지 않으면, 기본 값이 매개변수에 할당됨.

3. 키워드 인자(Keyword)
    - 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
    - 특정 매개변수에 값을 할당 할 수 있음
    - 인자의 이름을 명시하여 전달
    - 단, 호출 시 키워드 인자는 위치 인자 뒤에 위치해야 함. -> 순서의 모호성 때문.

4. 임의의 인자 목록(Arbitary)(가변)
    - 정해지지 않은 개수의 인자를 처리하는 인자
    - 함수 정의 시 매개변수 앞에 '*'를 붙여 사용
    - 여러 개의 인자를 tuple로 처리

    ``` python
    def calculate_sum(*args):
      print(args) # (1, 100, 5000, 30)
      print(type(args)) # <class 'tuple'>

    calculate_sum(1, 100, 5000, 30)

    ```

5. 임의의 키워드 인자 목록(Arbitary Keyword)(가변 키워드)
    - 정해지지 않은 개수의 키워드 인자를 처리하는 인자
    - 함수 정의 시 매개변수 앞에 '**'를 붙여 사용
    - 여러 개의 인자를 dictionary로 묶어 처리

    ``` python
    def print_info(**kwargs):
      print(kwargs)

    print_info(name = 'Eve', age = 30)
    ```

  ### 함수 인자 권장 작성 순서
  - 위치 -> 기본 -> 가변 -> 가변 키워드

## 재귀함수(Recursion)
  - 1개 이상의 종료상황이 존재하고 수렴하도록 작성
  - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
  - 메모리 사용량이 많고 느릴 수 있다.
  - 종료 조건이 잘못되면 스택 오버플로우 에러가 발생할 수 있다.(작업 공간에 일이 너무 많이 쌓여 프로그램이 멈추는 오류)
  - 복잡한 재귀함수는 오히려 코드의 가독성을 저하시킬 수 있다.

  ## 재귀 함수 활용 시 기억해야 할 것
    1. 종료 조건을 명확히 할 것
    2. 반복되는 호출이 종료 조건을 향하도록 할 것

## 내장함수(Built-in function)
  - 파이썬에 기본적으로 내장된 함수
  - 실행된 이후부터 영원히 유지
  - 별도의 import 없이 즉시 사용 가능
  - ex : max(), min(), len(), sum(), sorted()

## 함수와 Scope
  - 함수(function)는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분

  - local scope : 함수가 만든 scope. 함수 내부에서만 참조 가능
  - global scope : 코드 어디에서든 참조할 수 있는 공간

  - 이름 검색 규칙(LEGB Rule)
      - Local scope
      - Enclosed scope
      - Global scope
      - Built-in scope

  - 'global'키워드
      - 일반적으로 함수 내에서 전역변수를 수정하려는 경우에 사용
      - 변수의 스코프를 전역 범위로 지정하기 위해 사용
      - 매개변수에는 global 키워드 사용 불가

  ### 단일 책임 원칙
  - 모든 객체는 하나의 명확한 목적과 책임만을 가져야 함.
      ### 함수 설계 원칙
      1. 명확한 목적
          - 함수는 한 가지 작업만 수행
          - 함수 이름으로 목적을 명확히 표현

      2. 책임 분리
          - 데이터 검증, 처리, 저장 등을 별도 함수로 분리
          - 각 함수는 독립적으로 동작 가능하도록 설계

      3. 유지보수성
          - 작은 단위의 함수로 나누어 관리
          - 코드 수정 시 영향 범위를 최소화

  ## Packing & Unpacking
  ### Packing
  - 여러 개의 데이터를 하나의 컬렉션으로 모아 담는 과정
  - 한 변수에 ,로 구분된 값을 넣으면 자동으로 튜플로 처리
  - *args 매개변수, **kwargs 매개변수

  ### Unpacking
  - 컬렉션에 담겨있는 데이터들을 개별 요소로 펼쳐 놓는 과정
  - 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
  - '시퀀스 언패킹' 또는 '다중 할당' 이라고 부름

    ``` python
    def my_function(x,y,z):
      print(x,y,z)

    names = ['alan','jin','ganadi']
    my_function(*names)

    def my_function(x,y,z):
      print(x,y,z)

    my_dict = {'x':1,'y':2,'z':3}
    my_function(**my_dict)
    ```

    | 구분 | 상황 | *연산자 | **연산자
    | -- | -- | -- | -- |
    |패킹| 함수 정의 시 | 여러 위치 인자를 하나의 튜플로 받음 | 여러 키워드 인자를 하나의 딕셔너리로 받음 |
    |언패킹| 함수 호출 시 | 리스트/튜플을 개별 위치인자로 전달 | 딕셔너리를 개별 키워드인자로 전달 |

  ## return 반환은 1개만 가능.
    - 언제나 단 하나의 값(객체)만 반환할 수 있음.
    - 하나의 값, 하나의 튜플
    - return a,b,c 처럼 사용해도 값들을 하나의 튜플로 자동 패킹하여 반환.
    - 반환된 튜플들은 언패킹을 통해 사용할 수 있음
  
  ## 람다 표현식
  - 한 줄로 간단한 함수를 정의
  - 익명 함수를 만드는데 사용되는 표현식
    ``` python
    def addition(x,y):
      return x + y

    lambda x, y : x + y
    # lambda 키워드, 매개변수, 표현식
    ```

## 모듈(Module)
- 한파일로 묶인 변수와 함수의 모음
- 패키지를 구성하는 기본 단위
- 특정 기능을 하는 코드가 작성된 파이썬 파일(.py)

  ```python
  import math # 권장 : 명시적으로 불러오기 때문
  from math import pi, sqrt # from 절로 불러오기
  from math import sqrt as my_sqrt # 별칭부여

  print(math.pi)
  
  # 직접 정의한 모듈 사용하기
  # my_math.py를 생성하여 두 수의 합을 구하는 add 함수를 작성
  # 같은 위치에 sample.py 파일을 생성하고 my_math 모듈의 add함수 import 후 add 함수 호출
  ```
  
## 패키지(Package)
- 연관된 모듈들을 하나의 디렉토리에 모아 놓은 것
  ```python
  # my_package 폴더안에 math, statistics 폴더 생성 후 그 내부에 my_math, tools 파일 생성
  from my_package.math import my_math
  from my_package.statistics import tools
  ```
- PSL 내부 패키지
    - 설치 없이 바로 import
- 외부 패키지
    - 설치 할 때 'pip' 사용
    - 설치 시 (최신,특정,최소)버전 설치 가능

    - requests 패키지
      - 파이썬에서 웹에 요청을 보내고 응답을 받는 걸 아주 쉽게 만들어주는 외부 패키지

      ```python
      pip install requests
      import requests

      url = "<url 주소>"
      response = requests.get(url).json()
      print(response)
      ```
## 제어문
- 코드의 실행 흐름을 제어하는 데 사용되는 구문
- 조건에 따라 코드 블록을 실행하거나 반복적으로 코드를 실행
1. 조건문(if, elif, else)
    - 복수 조건문 : 조건식을 동시에 검사하는 것이 아니라 "순차적"으로 비교
    - 조건식의 순서에 따라 원하는 결과가 나오지 않을 수 있음을 주의

2. 반복문(for, while, break, continue)
  - for 반복문
    ``` python
    # for 변수 in 반복 가능한 객체 : 
    #     코드 블록
    ```    
    - 반복가능한 객체의 요소들을 반복하는데 사용
    - 반복 가능한 객체의 요소 개수 만큼 반복이 수행됨
    - 반복문에서 순회할 수 있는 객체 : list, tuple, str, dict, set
    - 인덱스로 리스트 순회
        ```python
        numbers = [4, 6, 10, -8, 5]
        for i in range(len(numbers)):
          numbers[i] = numbers[i] * 2
        
        print(numbers)  
        ```

    - 중첩된 반복문
        ```python
        outers = ['A', 'B']
        inners = ['c', 'd']

        for outer in outers:
          for inner in inners:
            print(outer, inner)
        ``` 

    - 중첩 리스트 순회
      - 안쪽 리스트 요소에 접근하려면 바깥 리스트를 순회하면서 중첩 반복을 사용해 각 안쪽 반복을 순회

        ```python
        elements = [['A','B'],['c','d']]

        for elem in elements:
          print(elem)
        ```  
  - While 반복문
    - 조건식이 참인 경우 동안 코드를 반복해서 실행
    - 조건식이 거짓이면 반복 종료
      ### 반드시 종료 조건이 필요

  - 반복 제어
  1. break
    - 남은 코드를 무시하고 반복 즉시 종료

  2. continue
    - 다음 코드는 무시하고 다음 반복을 수행

  3. pass
    - 아무 동작도 하지 않음

## map 함수
### map(function, iterable)
  - 반복 가능한 데이터 구조의 모든 요소에 function을 적용하고, 그 결과 값들을 map object로 묶어서 반환
  - 결과를 하나씩 꺼내 쓸 수 있는 반복 가능한 객체 자료형
  - 전체 값을 확인하려면 list나 tuple로 형변환을 해줘야 함.
  ```python
  numbers = [1,2,3]
  result = map(str, numbers)

  print(result)
  print(list(result))
  >>> ['1','2','3']
  ```
  - split() 메서드
    - 문자열을 지정한 기준 문자(기본은 공백)를 기준으로 잘라서, 잘린 문자들을 리스트로 반환해주는 문자열 메서드
    ``` python
    numbers1 = input.split()
    print(numbers1)
    >>> ['1', '2', '3']

    numbers2 = list(map(int,input().split()))
    print(numbers2)
    >>> [1, 2, 3]

    #map 함수 활용
    numbers = [1, 2, 3, 4, 5]
    def square(x):
      return x ** 2

    #lambda 미사용
    squared1 = list(map(square, numbers))
    print(squared1)
    >>> [1, 4, 9, 16, 25]

    #lambda 사용  
    squared2 = list(map(lambda x: x**2, numbers))
    print(squared2)
    >>> [1, 4, 9, 16, 25]
    ```
## zip 함수
### zip(*iterables)
### 행을 열로 열을 행으로 만들어준다.(전치행렬)
- 짝지어진 결과(tuple)를 하나씩 꺼내 쓸 수 있는 반복 가능한 객체 자료형
- 전체 값을 확인하려면 list나 tuple로 형변환을 해줘야 함.
- 반복  가능한 자료형의 길이가 다른 경우 가장 짧은 길이를 기준으로 묶어서 반환한다.
- 반드시 반복 가능한 자료형만 인자로 넣을 수 있다.
- zip object는 언패킹을 활용하여 변수에 바로 tuple 요소를 할당할 수 있다.
```python
girls = ['jane','ashley']
boys = ['peter','alan']
pair = zip(girls, boys)

print(pair)
print(list(pair))
>>> [('jane','peter'),('ashley','alan')]
  ```

## for-else문
  - for루프가 break를 만나 중단되지 않고, 끝까지 정상적으로 완료되었을 때만 else블록이 실행
  - 모든 반복을 수행했을 때만 실행된다.
  - 만약 break를 만나 종료되는 경우 else문은 실행되지 않는다.
  ```python
  for i in range(5):
    print(i)
    if i == 3:
      print("반복이 중단되었습니다.")
      break
  else:
    print("이 메시지는 출력되지 않습니다.")

  >>> 
  0
  1
  2
  3
  반복이 중단되었습니다.
  ```

## enumerate
### enumerate(iterable, start=0)
- iterable 객체의 각 요소에 대해 인덱스와 값을 함께 반환하는 내장함수
- start에 시작 값을 설정할 수 있음
- 인덱스 정보를 이용해 요소의 위치를 확인할 수 있음
```python
fruits = ['apple','banana','cherry']

for index in fruit in enumerate(fruits):
  print(index, fruit)
>>>
0 apple
1 banana
2 cherry

respondents = ['은지', '정우', '소민', '태호']
answers = ['', '좋아요', '', '괜찮아요']

for i, response in enumerate(answers):
  if response == '':
    print(f"{respondents[i]} 미제출")
>>>
은지 미제출
소민 미제출
```
