# list, dict, set, tuple, range

## list, dict

# list : 여러개의 값을 순서대로 저장한다. + 변경 가능한(mutable) 시퀀스 자료형
    # 모든 종류의 데이터를 담을 수 있음. + 값을 추가, 수정, 삭제 가능 ==> 가변.
    # 시퀀스 = 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능 사용 가능. + 중첩 리스트
    # 중첩 리스트 : 구조 안에 같은 구조가 존재.

# list : 변경 가능(가변(수정,추가,삭제 가능)) + 시퀀스(인덱싱, 슬라이싱 등 가능)

# str : 변경 불가능한 + 시퀀스 자료형

# dict : 변경 가능 + 순서 없음 + 중복 없음
    # key-value 쌍으로 이루어져 있음.
    # key는 중복 불가
        # 변경 불가능한 자료형만 사용 가능(str, int, float, tuple)
        # 사용 불가능한 자료형(list, dict)
        # Key에 접근 시 대괄호[] 사용.
        # 존재하지 않는 key로 접근하면 key error 발생 + 프로그램 멈춤

# set : 변경 가능 + 순서 없음 + 중복 없음
    # 집합 연산 처리
    # 중괄호 {} 안에 값들을 구분
        # 합집합 : |, union
        # 차집합 : -, difference
        # 교집합 : &, intersection

# tuple : 변경 불가능(값을 순서대로 저장) => 한번 만들어지면 절대 수정 불가능 + 시퀀스 자료형
    # 불변 특성을 사용해서 내부 동작과 안전한 데이터 전달에 사용.
    # 안정성과 무결성 보장

# range : 시퀀스 + 변경 불가능한 자료형
    # 메모리를 효율적으로 사용 가능.
    # list로 형변환 시 내부 값을 확인 가능.
    # 방향 일치 시켜야 함.

# None : 값이 존재하지 않음. 아직 정해지지 않음

# Boolean : True, False 2가지 값만 가지는 데이터 타입

# Collection : 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말.
# 불변 : 안전성, 예측 가능
# 가변 : 유연성, 효율성

# |  컬렉션 명   |   변경 가능 여부    |   순서 존재 여부  |   중복 가능 여부  |
# |  list       |       O           |       O         |       O         |
# |  str        |       X           |       O         |                 |
# |  tuple      |       X           |       O         |                 |
# |  dict       |       O           |       X         |       X         |
# |  set        |       O           |       X         |       X         |
# |  range      |       X           |                 |                 |

# 형변환 : 데이터 타입을 다른 데이터 타입으로 변환 하는 과정
# 암시적 형변환 : 연산 중에 자동으로 데이터 타입을 변환 하는 것.
# 명시적 형변환 : 개발자가 직접 함수로 지정하여 변환하는 것.

# == 연산자 : 값(데이터)이 같은지를 비교
# is 연산자 : 객체 자체가 같은지를 비교 => 메모리 주소가 같은지를 확인할 때 사용.
    # 싱글턴 객체를 비교할 때 사용
        # 특정 값에 대해 단 하나의 객체만 생성되어 재사용되는 특별한 객체
        # 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
        # None, True, False

# ex:
# a = [1, 2, 3]
# b = [1, 2, 3]
# print(a == b) -> True(값은 동일)
# print(a is b) -> False(서로 다른 리스트 객체 => 주소값은 다름)
# b = a -> 이제 주소값이 같아짐.
# print(a is b) -> True

# 논리연산자
    # 단축 평가 : 두 번째 피연산자를 평가하지 않고 결과를 결정.
        # and 연산자 : 연산을 왼 --> 오로 진행하다가 처음 거짓 값을 만나면 바로 반환
        # or 연산자 : 왼 --> 오 방향으로 진행하다가 처음 참을 만나면 바로 반환

# 멤버십 연산자(in, not in)
# : 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

### 연산자 우선순위
# ()                        소괄호
# []                        인덱싱, 슬라이싱
# **                        거듭제곱
# +, -                      단항 연산자(양수, 음수) = (우 ~> 좌로 연산 수행)
# *, /, //, %               산술연산자
# +, -                      산술연산자
# <, <=, >, >=, ==, !=      비교연산자
# is, is not                객체 비교
# in, not in                멤버십 연산자
# not                       논리 부정
# and                       논리 AND
# or                        논리 OR


#############################################################################################################
# 원격제어 설정
#git remote add origin [url주소]
#git remote -v

# push : 실제로 데이터를 원격 저장소에 올림 ==> 지금까지 만든 커밋이 올라감
#로컬 ----> 깃 헙 래퍼지토리
#[git push] [origin] [master] : 깃아 푸시해줘, 오리진 이라는 이름의 원격 저장소에 마스터라는 이름의 브랜치를.

# pull or clone : 원격 저장소에서 내게 가져옴.
#깃 헙 래퍼지토리 <------- 로컬
#[git pull] [origin] [master] : 원격 저장소의 변경사항만! 을 받아옴(업데이트)
#[git clone] [remote_repo_url] : 원격 저장소 전체! 를 복제(다운로드) -> 클론 받은 프로젝트는 이미 git init이 되어있다.

# 중요! #
# 클론을 통해서 개발에 참여
# 풀을 통해서 개발의 변경 사항을 업데이트해서 작업 준비를 한다.

# 푸시하고 풀 해야 2개 상황이 같아짐.
# 보통 출근하자 마자 풀을 진행해서 같아지게 만듬.

# 깃헙에올라가면 좋은점 :
# 그동안의 있었던 변경사항들을 확인할 수 있다.

### 원격 저장소에는 커밋이 올라가는 것.
### 커밋 이력이 없다면 푸쉬 할 수 없다.

# git remote -v : 현재 로컬 저장소에 등록된 원격 저장소 목록 보기
# git remote rm : 현재 로컬 저장소에 등록된 원격 저장소 삭제
# git push --set-upstream origin master(git push -u origin master)
#: master 브랜치의 원본 브랜치를 origin의 master를 원본으로 기록
#: 이후 git pull 등의 다른 명령어에서 특별한 인자가 없을 경우 origin의 master 브랜치의 기록을 가져옴

# gitignore : Git 에서 특정 파일이나 디렉을 추적하지 않도록 설정하는데 사용되는 텍스트 파일.
# --> 프젝에 따라 공유하지 않아야 하는 것들도 존재하기 때문.

# gitignore : 
#.venv ==> 큰 파일 + 공유되면 안되는 파일. 내 컴터를 기준으로 동작하기 때문(깃에 포함되면 안되는 파일)
#이런걸 실수로 add push 하게 되면 문제 발생.
#==> 몇몇 파일을 빼고 add push를 하기 위해서 gitignore 파일을 사용.
#==> 변경 사항을 감시하지 않겠다.

#U 언트랙트 -> 아직 깃이 어떤 상태인지 판단 못함.

#.gitignore 내부에 a.txt를 적어놓으면
#status에 잡히지 않음

#git add sample.txt ^C
#git add --all ==> 실수 발생 가능성 존재.

#sample.txt 같은 경우 이미 보고 있는 상태.
#새로 추가 하고 저장한 다음 git status 사용하면 sample.txt파일은 모디파이 작업에 추가되어져 있음.
#==> 여전히 추적되는 중.
#이미 추가되어진 파일은 아무리 올려도 없어지지 않음.

### 반드시 프젝 시작하는 단계에서 gitignore 작성하는 것이 좋음.
#못했을때-> git tm --cached 명령어를 통해 수동으로 git 캐시에서 삭제를 진행해야 한다.
###

## gitignore.io 사이트 가서 진행하는 언어 작성하고 거를 파일 확인.
#https://www.toptal.com/developers/gitignore/api/python

# 
#새로운 폴더 생성 후 로컬 저장소 설정 = git init
#commit 목록 생성 : add
#새로운 깃허브 래퍼지토리 생성 remote
#원격 저장소 추가 : add origin
#커밋 목록 푸쉬

# 실습
#기존에 이미 오리진을 추가한 로컬 저장소에 이어서 진행
#새로운 깃헙래퍼지토리 생성
#오리진이 아닌 다른 이름으로 원격 저장소 추가 : gir remote add extra [url]
#커밋 목록 푸쉬
####################################
# Revert & Reset
#Revert : 없던 일로 만들기
#Reset : 되돌아가기

# Git revert : 특정 커밋을 없었던 일로 만드는 작업
## 커밋에서 있었던 일이 잘못되었다 라는 상황에서 실행. 2번 커밋에 있었던 내용이 다 사라짐.

#git revert <commit id>최소 4자 작성 => 깃 로그 치면 나오던 것 중 노랭이
# 단일 커밋을 실행 취소하는 것.
# 커밋을 없었던 일로 처리 후 그 결과를 새로운 [커밋]!!!!으로 추가함.
#(이전 작업을 없애는 커밋을 작동)

#vim => CLI의 메모장 프로그램
#:wq

# 날려버릴땐(리버트를 하면) 다른 개발자들도 알아야하기 때문에 기록을 추가적으로 남김
# 리버트 정리 : 기록의 손실을 방지. 안전하게 실행 취소할 수 있는 순방향 실행 취소 작업. 무결성과 협업의 신뢰성을 높임

# 리버트 추가 활용법 확인(교재)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ #
# Git reset : 특정 커밋을 이전으로 되돌아가기(타임머신)

#git reset [옵션] <commit id> :  커밋 아이디 까지 되돌아가기
#0 --> 0 --> 0 --> 0
#리버트는 역사는 기록됨.
#하지만 리셋은 타임머신으로 돌아가서 다음 기록들은 같이 사라짐.

#리셋 옵션 3가지 :
#= 삭제되는 커밋들의 기록을 어떤 영역에 남겨둘 것인지 옵션을 활용해 조정
#--soft : 삭제된 커밋들의 기록을 [스테이징 에리아]에 남김. 
#		> 다음 커밋을 만들게 되면 커밋에 있었던 변경 사항들은 다음 커밋에 추가가된다.(스테이징 에리아에)
#		= 흔적은 남겨 둠. A로 바뀜// changes to be committed: 로 바뀜

#--mixed : 삭제된 커밋들의 기록을 [워킹 디렉]에 남김(기본값) : 내가 다음에 커밋하면 남지 않음. 남기고 싶으면 add해야 함.
#(기본값)	U로 바뀜 언트랙드로 모여있음// Untracked files: 로 바뀜

#--hard : 삭제된 커밋들의 기록을 남기지 않음.
#	파일이 바로 삭제됨.
	
# 리셋은 만들어진 커밋을 되돌리는 행위
# 리모트에 올라간 커밋은 절대 리셋 해서는 안됨.
#이미 올라간 커밋의 경우 리버트 활용.
#######################################

#깃헙에 올릴만한 것들 제안.
#깃헙(개발자 sns)
#1. 프젝 협업
#2. 개인 포폴

#TIL을 통해 내가 학습하는 것을 기록.
#(투데이 아이 런드) 파이썬, 리모트 래퍼지토리~
#: 스스로 기록하는 습관만들어서 문서화 GOGO

# 문서화의 중요성 : 동료 개발자에게 무엇을 해야할지 정리해주기.

### TIL 알고리즘 문제 풀고 올리기
# 구조 정답은 없음.
# 닥 - 1일 1 TIL
# readme.md를만들어서 첫 페이지로 보이게끔.
# 자소서 형식으로 만들어짐

###
#git commit --amend : 바로 직전 커밋을 조금만 수정.
# 실습 진행
# 주의사항 : 결국 커밋을 수정하는 행위.
# --> 올라간 커밋은 하지 않는 것이 바람직함.

# 파일 내용을 수정 전으로 되돌리기.
#git restore : 깃에 기록되어져있는 상태로 (add 전) --> 복원 절대 불가능.

#ex) sample.txt에 안녕하세요. 에서 한 줄 추가. 반갑습니다.
#생각해보니 추가안해도될듯 함. 그래서 마지막 상태로 되돌리고 싶다. 할 때 사용(add도 하기 전)

### 스테이징 에리아에 올라간 파일 언스테이징 하기.
#--> 스테이징 에리아 에서 워킹 디렉으로 되돌리기.
#git restore --staged : 
#마지막 커밋으로 돌아감.

#git rm --cached : 
#--> 스테이징 에리아 또는 래퍼지토리에 포함된 파일을 git 에서만 제거한다.
#스테이징 에리아에서 제거하고 파일은 유지되기 때문에, 결과적으로 add가 취소된다.
#: 실제 워킹 디렉에 유지. 스테이징 에리아 에서만 파일을 제거하게 됨.
#: add했던 내역이 취소되고 파일은 유지

##########
#삭제한 커밋으로 돌아가기.
#git reflog









